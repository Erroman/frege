--- Tests for 'Decimal' numbers
module tests.qc.Decimals where

import Test.QuickCheck as QC (quickCheck, verboseCheck, property, ==>, once, Arbitrary, classify, label, Prop, Gen)
import Data.Dec64 hiding(>>)
import Data.Dec64 (¦)


instance Arbitrary Decimal where
    arbitrary = do  -- Decimal.fromBits <$> arbitrary
        m ← (Long.shiftL 8) <$> arbitrary
        x ← (Int.shiftR 24) <$> arbitrary
        pure (Decimal.fromBits (m ¦ x.long))   


-- p_dummy = once true

--- For positive numbers, 'divu10' is equivalent to @(`quot` 10)@
p_quot = property g where
    g n = n != minBound ==> divu10 (abs n) == abs n `quot` 10

--- For positive numbers, 'remu10' is equivalent to @(`rem` 10)@
p_rem = property g where
    g n = n != minBound ==> remu10 (abs n) == abs n `rem` 10

--- 'mulu10' is equivalent to @(*10)@
p_mul = property g where
    g n = mulu10 n == n*10L
    
--- For positive numbers @p@, @divu10 p * 10 + remu10 p@ is @p@
p_division = property g where
    g n = n != minBound ==> abs n == divu10 (abs n) * 10 + remu10 (abs n)

--- addition is commutative, this should even hold for addition of 'Decimal.nan' 
p_add_commutative = property g where
    g :: Decimal → Decimal → Bool
    g a b = a+b == b+a

--- this holds when one allows 1 'ulp' for rounding errors
p_add_associative = property g where
    g ∷ Decimal → Decimal → Decimal → Gen Prop 
    g a b c = case (a + b) + c of 
        left → case a + (b + c) of
            right | left == right                = label "equal" true
                  | nextUp left == right
                    || nextDown left == right    = label "different by 1 ulp" true
                  | otherwise = label "not associative" true

--- 0 is the neutral element in addition
p_zero_neutral_add = property g where
    g x = x+0z == x

--- @a + (-a) == 0@
p_negate = property g where
    g x = x.coefficient != Decimal.minCoefficient 
            ==> classify (Decimal.isNaN x) "not a number" 
                    (if x.isNaN then true else x + negate x == 0)

--- multiplication is commutative
p_mul_commutative = property g where
    g :: Decimal → Decimal → Bool
    g a b = a*b == b*a

--- not sure if this actually holds
p_mul_associative = property g where
    g ∷ Decimal → Decimal → Decimal → Gen Prop 
    g a b c = case (a * b) * c of 
        left → case a * (b * c) of
            right | left == right                = label "equal" true
                  | nextUp left == right
                    || nextDown left == right    = label "different by 1 ulp" true
                  | otherwise = label "not associative" true

--- multiplication with 'Decimal.zero' is 0
p_mul_zero = property g where
    g a = a*0z == 0z

--- 1 is the neutral element in multiplication
p_one_neutral = property g where
    g a = 1z*a == a
