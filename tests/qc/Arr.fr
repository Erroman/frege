--- Test properties of the 'Arr' module
module tests.qc.Arr where

import frege.Prelude hiding(Object)

import Data.Ix
import Data.Arr as A
import Test.QuickCheck as Q public

type CIArray = Array Char Int

intBounds :: Gen (Int, Int)
intBounds = do
    a <- choose (0, 100)
    b <- choose (0, 100)
    return (a,a+b)

charBounds :: Gen (Char, Char)
charBounds = do
    a <- elements ['a'..'m']
    b <- elements ['l'..'z'] -- 'm' and 'l' makes empty bounds
    return (a,b)

emptyRange = elements [(42,41)]

checkBounds :: (Ix i, Show i) => (Gen (i, i)) -> Property
checkBounds g = forAll g (\b -> (array b []).bounds == b)

checkElems :: (Show a, Eq a) =>[a] -> Bool
checkElems a = (listArray (1, length a) a).elems == a

checkIndices :: (Enum i, Show i, Ix i) => (i,i) -> Bool
checkIndices (l,u) = let i = (array (l,u) []).indices
                     in if (l<=u) then i == [l..u] else i == []

checkIndicesGen :: (Enum i, Show i, Ix i) => Gen (i,i) -> Property
checkIndicesGen g = forAll g checkIndices

-- helper for crating one-based indexed Arrays
listArr elems = listArray (1, length elems) elems

checkFoldrSum elems = foldrElems (+) 0 (listArr elems) == sum elems

checkFoldrSumStrict elems = foldrElems' (+) 0 (listArr elems) == sum elems

checkFoldlSum elems = foldlElems (+) 0 (listArr elems) == sum elems

checkFoldlSumStrict elems = foldlElems' (+) 0 (listArr elems) == sum elems

checkFoldr1Sum elems = elems == [] || foldr1Elems (+) (listArr elems) == sum elems

checkFoldl1Sum elems = elems == [] || foldl1Elems (+) (listArr elems) == sum elems

checkFmap elems = (fmap (*2) (listArr elems)).elems == map (*2) elems

checkEq elems = (listArr elems) == (listArr elems)

checkAccumArray elems = accumArray (+) 0 bounds (assocs++assocs) == listArray bounds (map (*2) elems)
                        where n = length elems
                              bounds = (1,n)
                              assocs = zip [1..n] elems

checkIxmap = (ixmap ('a','z') ord (array (97, 122) elems)) == array ('a','z') [(a, ord a) | a<-['a'..'z']]
                where elems = map (\x->(x, x)) [97..122]

checkCmp (e1,e2) = (e1 <=> e2) == ((listArr e1) <=> (listArr e2))

p_boundEmpty        = once (checkBounds emptyRange)
p_boundChars        = property (checkBounds charBounds)
p_boundInts         = property (checkBounds intBounds)
p_elemsChars        = property (checkElems::[Char]->Bool)
p_elemsInts         = property (checkElems::[Int]->Bool)
p_elemsStrings      = property (checkElems::[String]->Bool)
p_indicesChars      = property (checkIndices::(Char,Char)->Bool)
p_indicesInts       = property (checkIndicesGen intBounds)
p_twoDimensional    = once ((listArray (('a',false),('b',true)) [0,1,2,3]).assocs == [(('a',false),0),(('a',true),1),(('b',false),2),(('b',true),3)])
p_undefinedAreLazy  = once ((array (1,2) [(2,true)] !@ 2) == true)
p_foldr             = property (checkFoldrSum :: [Int] -> Bool)
p_foldrStrict       = property (checkFoldrSumStrict :: [Int] -> Bool)
p_foldl             = property (checkFoldlSum :: [Int] -> Bool)
p_foldlStrict       = property (checkFoldlSumStrict :: [Int] -> Bool)
p_foldr1            = property (checkFoldr1Sum :: [Int] -> Bool)
p_foldl1            = property (checkFoldl1Sum :: [Int] -> Bool)
p_fmap              = property checkFmap
p_eq                = property (checkEq :: [Char] -> Bool)
p_accumArray        = property (checkAccumArray :: [Int] -> Bool)
p_ixmap             = once checkIxmap
p_updated           = once (listArr [1,2,3] // [(1,0),(3,0)] == listArr [0,2,0])
p_cmp               = property (checkCmp :: ([Char], [Char])-> Bool)
