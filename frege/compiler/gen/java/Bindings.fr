
{--
    Heart of the code generation.
    
    Determination of appropriate java types and conversions between lazy, strict, known
    and unknown values.
    
    -}

module frege.compiler.gen.java.Bindings
        inline (adaptSigma, adaptSigmaWith) 
    where

import frege.Prelude hiding(<+>)

import Data.TreeMap (TreeMap Map)
-- import Data.List as DL(zip4)
import Data.Bits(BitSet.member)


import  Compiler.common.Errors as E()
-- import  frege.lib.PP hiding(group, break, line)
-- import  Compiler.types.Positions
-- import  Compiler.enums.Flags(TRACEZ)

import  Compiler.Utilities as U()
import  Compiler.gen.java.Common

import  Compiler.enums.RFlag(RValue)

import  Compiler.common.Mangle(romanUpper)

import  Compiler.types.AbstractJava
import  Compiler.types.Strictness
import  Compiler.types.JNames(memberOf, JName)
import  Compiler.types.Types
-- import  Compiler.types.Symbols
import  Compiler.types.ConstructorField(Field, ConField)
import  Compiler.types.QNames(QName)
import  Compiler.types.Global as G

import  Compiler.classes.Nice(Nice)


{--
 * This data structure describes java compile time types
 * of some frege item (argument, return value, field, expression) 
 * and java expression associated with it.
 * 
 * The task of code generation is to create, combine and
 * manipulate such bindings. Many code generating functions will take
 * a ('Tree' 'Symbol' 'Binding') of current bindings as last parameter.
 -}
data Binding = Bind {?stype :: String, !ftype::Sigma, !jtype :: JType, !jex :: JExpr}
instance Show Binding where
    show (Bind {stype, jtype, jex}) = "Bind {" 
                                            ++ stype ++ ", "
                                            ++ show jtype ++  ", "
                                            ++ showJex jex ++ "}"

newBind g sigma jex = Bind{stype=nicer sigma g, 
                        ftype=sigma, jtype=sigmaJT g sigma, jex}

--- tell if the item we are working with is strict  
isStrictJT :: JType -> Bool
isStrictJT Lazy{yields}          = false
isStrictJT _                     = true

--- tell if the item we are working with is known
isKnownJT :: JType -> Bool
isKnownJT Something             = false
isKnownJT Lazy{yields}          = isKnownJT yields
isKnownJT _                     = true



{--
    - If the 'RAlways' flag is set, the return type will always be @Lazy@
    - If the 'RValue' flag is on, the return type will be @int@, @String@ or @TList@
    - Otherwise, lazy as well as non lazy results may be returned. For native types, 
      this means the return type is @Something@. Frege types are returned as @Lazy@.
-}
returnType mode rjt = if RValue `member` mode 
    then strict rjt
    else lazy rjt

{--
    convert an arg quadrupel to a 'Binding'
    -}
arg2Bind g = quadBind g JAtom 

quadBind g f (_, sig, jt, s) = Bind (nicer sig g) sig jt (f s)

{--
     Adapt a 'Binding' to the required strictness and target type.
    --}
adaptBind :: Global -> Binding -> Strictness -> Binding
adaptBind g bind s
     = adaptSigmaWith (if Strictness.isStrict s then strict else lazy) g bind
        
 
--- adapt argument to wanted strictness
adaptArg g a s = adaptBind g (arg2Bind g a) s

--- instantiate 'Binding' for an Argument
instArg g a = adaptSigma g (arg2Bind g a)

--- Invoke method with single argument
invokeSingle meth arg = JInvoke meth [arg]


--- force a lazy 'Binding'
force :: Binding -> Binding
force Bind{stype, ftype, jtype = Lazy{yields}, jex}
                    = Bind{stype, ftype, jtype = boxed yields, 
                            jex = JInvoke JExMem{jex, name="call", targs=[]} []}

force bind 
    = error("unneeded force: " ++ show bind)

--- Force a lazy @bind@ and give it type @to@
--- This is only possible for 'Bindings' having type @Lazy Something@
forceTo :: Binding -> JType -> Binding
forceTo bind to
    | Lazy Something <- bind.jtype = (force bind).{jtype=to, jex <- JCast to}
    | otherwise = error("cannot forceTo: " ++ show bind ++ " to " ++ show to)

     
{-- 
    Delay a 'Binding' by wrapping it in a Lazy lambda, see 'lazyIt'

    -}
delay :: Binding -> Binding
delay bind = bind.{jex ‚Üê lazyIt bind.jtype, jtype ‚Üê lazy}

{--
    Put a native value in a frege.run.Box
-}
putBox bind = case bind of
    Bind{stype, ftype, jtype=Nativ{typ, gargs=[t], generic}, jex}
        = Bind{stype, ftype, 
                jtype = box,
                jex = JNew box [jex]} 
        where box = Box{yields=bind.jtype, phantom=t}
    other ‚Üí error ("putBox: can't make Box from " ++ show bind)

{--
    Get a native value out of a Box.
-}
getBox bind = case bind of
    Bind{stype, ftype, jtype=Box{yields, phantom}, jex}
        = bind.{jtype=yields, jex ‚Üê JX.invoke [] . JX.xmem "call"}
    other ‚Üí error ("getBox: not a box: " ++ show bind) 

{-- 
    coerce Kinded<T<A,B,C,?,...>,D,...> to T<A,B,C,D,...>

    The name of the corece function for functions is @Func.coerceX@
    where X is the roman number of the arity,
    otherwise just T.coerce
-}
coerceKinded g Bind{stype, ftype, jtype, jex} = case jtype of
    Kinded{arity,gargs = un:args} -> case un of
        Func{gargs} ‚Üí Bind{stype, ftype, jtype = target, jex = coex}
            where
                target = Func (take (farity - arity) gargs ++ args)
                name   = "coerce" ++ romanUpper (farity - 1)
                smem   = JX.staticMember (JName (funcName g) name)
                gmem   = smem.{targs = target.gargs}
                coex   = JInvoke gmem [jex] 
                farity = length gargs
        Box{yields, phantom} = Bind{stype, ftype, jtype = target, jex = coex}
            where
                target = fromKinded jtype
                gmem   = JStMem (nativ "Box" []) "coerce" [target.yields, target.phantom]
                coex   = JInvoke gmem [jex] 
        other | other.{gargs?} = Bind{stype, ftype, jtype = target, jex = coex}
            where 
                tarity = length other.gargs
                target = other.{gargs = take (tarity - arity) other.gargs ++ args}
                gmem   = JX.static "coerce" target
                coex   = JInvoke gmem [jex]
        _ -> error ("coerceKinded no suitable target type: " ++ show jtype)
    _ -> error ("coerceKinded argument not kinded: " ++ show jtype)

--- Implement some special hacks. The code for them is generated verbatim into the PreludeBase.
specialHack ‚à∑ Global ‚Üí JType ‚Üí JType ‚Üí Maybe JExpr
{--
    We have:
    > PreludeBase.TMaybe<PreludeBase.TTuple2<ùìî, String/*<ùìî>*/>>
    We want:
    > PreludeBase.TMaybe<PreludeBase.TTuple2<ùìî, Kind.U<Box<String/*<ùìî>*/,?>, ùìî>>>
-}
specialHack g from to = go specials
    where
        go ((t1,t2,x):xs) = case unifyJT from t1 empty of
            Right _ ‚Üí case unifyJT to t2 empty of
                Right _ ‚Üí Just x
                other   ‚Üí go xs
            other       ‚Üí go xs
        go [] = Nothing             -- No Way, Sorry.

private specials = [(unconsFrom, unconsTo, unconsHack)]
private unconsFrom = tMaybe (tTuple a (tString a))
private unconsTo   = tMaybe (tTuple a (asKinded Box{yields=tString a, phantom=a} 1))
private a          = TArg "a"
private tString a  = Nativ "java.lang.String" [a] false
private tTuple a b = ref "TTuple2" [a,b]
private ref s xs   = Ref{jname=JName "PreludeBase" s, gargs=xs}
private tMaybe a   = ref "TMaybe" [a] 
private unconsHack = JStMem{jt=nativ "PreludeBase" [], name="unconsHack", targs=[]}


infixl 5 adapt  
{--
    Adapt a binding to a given target type

    Note that all adaptions should be justified through type checking.
    In particular, we are not doing exhaustive Java type checking here.

    If the conversion is undefined, this hints at a compiler error.
    -}
adapt ‚à∑ Global ‚Üí Binding ‚Üí JType ‚Üí Binding
adapt g bind toType = case adaptQ g bind toType of
    Right newb      ‚Üí newb
    Left (from, to) ‚Üí if try from to 
                        then case bind.jtype of
                            Ref{} | toType.{gargs?} 
                                  -> bind.{jtype = toType, 
                                           jex = JX.invoke [] (
                                                 JExMem{jex=bind.jex, 
                                                        name="simsalabim", 
                                                        targs = toType.gargs}
                                            )}
                            -- this will probably work too, but triggers "Unchecked" warning
                            other ‚Üí bind.{jtype = toType, jex ‚Üê JCast toType . JCast Something} 
                        else case specialHack g bind.jtype toType of 
                            Just callit ‚Üí bind.{jtype = toType, jex ‚Üê JInvoke callit . pure} 
                            _ ‚Üí  error ("Can't adapt\n" 
                                ++ show bind 
                                ++ "\nto  " 
                                ++ show toType
                                ++ "\nbecause  "
                                ++ show from
                                ++ "  does not match  "
                                ++ show to)
        where
            try from to = case from of
                Kinded{}
                    | canBeKinded to from.arity
                    = case unifyJT from (asKinded to from.arity) Map.empty of
                                     Right _    ‚Üí true
                                     Left (f,t) ‚Üí try f t
                    | otherwise   = false
                _ = case to of 
                    Kinded{} 
                        | canBeKinded from to.arity
                        =  case unifyJT (asKinded from to.arity) to Map.empty of
                                     Right _    ‚Üí true
                                     Left (f,t) ‚Üí try f t
                        | otherwise  = false
                    _   = false


adaptQ g bind toType
    = case unifyJT bind.jtype toType Map.empty of 
        Right _  = accept
        Left (f1, f2) = case bind.jtype of
            Lazy{yields}
                        = case toType of
                            -- the following maps `adapt` over Lazy
                Lazy{}      = delay <$> adaptQ g forced toType.yields
                _           = adaptQ g forced toType
            Kinded{}    = case toType of
                Lazy to     = ensureLazy <$> adaptQ g bind to
                Kinded{}    = cannot f1 f2
                _           = adaptQ g unkinded toType
            Box{} | Nativ{} ‚Üê toType
                            = adaptQ g fromBox toType
            Nativ{}
                | Just _ ‚Üê  isPrimitive bind.jtype, Nothing ‚Üê isPrimitive toType
                            = adaptQ g boxit toType
                | Nothing ‚Üê isPrimitive bind.jtype, Just _ ‚Üê  isPrimitive toType
                            = adaptQ g unboxed toType
                | Box{} <- toType
                            = adaptQ g asBox toType
                | Kinded{} <- toType
                            = adaptQ g asBox toType
            nonlazy     = case toType of
                Lazy to     = ensureLazy <$> adaptQ g bind to
                Kinded{arity} 
                    | canBeKinded nonlazy arity,
                      Right _ <- unifyJT (asKinded nonlazy arity) toType Map.empty
                    = casted 
                Something   = accept 
                _           = cannot f1 f2
            -- _           = cannot
          where cannot f1 f2
                    | traceLn("cannot: from " ++ show f1 ++ " to " ++ show f2) || true   
                    = Left (f1, f2)

    where
        unboxed  = bind.{jtype = p, jex ‚Üê JCast p}
                    where p = strict bind.jtype
        boxit    = bind.{jtype ‚Üê boxed}
        accept   = Right bind.{jtype = toType}
        casted   = Right bind.{jtype = toType, jex ‚Üê JCast toType}
        asBox    = putBox bind
        fromBox  = getBox bind
        forced   = force bind
        unkinded = coerceKinded g bind

--- make sure the binding can be passed as Lazy 
ensureLazy :: Binding ‚Üí Binding
ensureLazy bind  = case bind.jtype  of
    Lazy{yields}            ‚Üí  bind 
    Constr{jname, gargs}    ‚Üí  error ("Can't lazy a constraint " ++ show bind)
    t | implementsLazy t    ‚Üí  bind.{jtype ‚Üê lazy}
    other                   ‚Üí  bind.{jex ‚Üê lazyJX bind.jtype, jtype ‚Üê lazy} 

delayBind ‚à∑  Binding ‚Üí Binding 
delayBind bind = bind.{jex ‚Üê thunkIt bind.jtype . Left, jtype ‚Üê lazy}

    
--- make sure a strict binding actually is primitive if type allows
primitiveBind g bind
    | Nativ{} <- sbind.jtype,
      prim != sbind.jtype       = sbind.{jtype = prim, jex <- JX.cast prim}
    | otherwise                 = sbind
    where
        sbind = strictBind g bind
        prim  = strict sbind.jtype
 

---    make a binding strict
strictBind ‚à∑ Global ‚Üí Binding ‚Üí Binding
strictBind g bind = adapt g bind (strict bind.jtype)

---    make a binding lazy
lazyBind ‚à∑ Global ‚Üí Binding ‚Üí Binding
lazyBind g bind = adapt g bind (lazy bind.jtype)

adaptSigmaWith f g bind = adapt g bind (f (sigmaJT g bind.ftype))
adaptSigma       g bind = adapt g bind (  (sigmaJT g bind.ftype))

{--
    [usage] @realize bind@

    code to create a local variable and an updated bind
    -}
realize :: String -> Binding -> StG (Binding, [JStmt])
realize name bind
    | cheap (Binding.jex bind) = do
        g <- getST
        stio (bind, [sComment ("too cheap to realize " ++ name ++ " bound to " ++ show bind)])
    | otherwise = do
        u <- uniqid
        g <- getST
        let vname = m name -- ++ underline ++ show u  -- must correspond to U.javaName
            m "$" = "$" ++ show u
            m s   = s
            member = JMember {attr = attrFinal,
                            jtype = Binding.jtype bind,
                            name = vname,
                            init = Just (Binding.jex bind)}
            nbind = bind.{jex = JAtom vname}
        stio (nbind, 
                [sComment ("realize " ++ name ++ " bound to " ++ show bind), 
                 JLocal member])

assign :: Global -> ConField QName -> FormalArg -> JStmt
assign g Field{pos, name = Just toname, doc, vis, strict, typ} formalArg  
        = JAssign (JAtom toname) bind.jex
    where
        bind   = adaptArg g formalArg (if strict then S[] else U)
assign g f a = error "assign: apply only named fields here"     -- see namedFields
