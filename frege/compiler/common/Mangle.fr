--- This is an undocumented module
module frege.compiler.common.Mangle where

import Data.TreeMap as TM
import Data.Tuples()
import Compiler.common.Binders( jtvArray )


{--
 * Java keywords (along with substitutions)
 * as specified in the Java Language Specification, Version 3.0, page 21
 * and, in addition, "true", "false", and "null"
 *
 * It is, for instance, possible to name a frege item _int_, though
 * in the generated java code, this will appear as \__int_.
 *
 -}
!javakeywords = TM.fromList  [(kw, "_"++kw) | kw <- [
    "abstract",     "continue",     "for",          "new",          "switch",
    "assert",       "default",      "if",           "package",      "synchronized",
    "boolean",      "do",           "goto",         "private",      "this",
    "break",        "double",       "implements",   "protected",    "then",
    "byte",         "else",         "import",       "public",       "throws",
    "case",         "enum",         "instanceof",   "return",       "transient",
    "catch",        "extends",      "int",          "short",        "try",
    "char",         "final",        "interface",    "static",       "void",
    "class",        "finally",      "long",         "strictfp",     "volatile",
    "const",        "float",        "native",       "super",        "while",
    -- also the literals, as variables cannot be named like so
    "true",         "false",        "null",
    -- likewise assert and main, in order to avoid confusion
    "assert",       "main",
    -- forgot throw
    "throw"
    ]]



repljavakws s = case TreeMap.lookupS javakeywords s of
    Just k  -> k
    Nothing -> s



--- replacement for certain graphic characters ∀
!graphReplacements = TM.fromList . map (fmap unpacked) $ [
    ('°', "_deg"),  ('^', "_caret"),    ('!', "_excl"), ('²', "_two"),  ('³', "_three"),
    ('§', "_par"),  ('%', "_pct"),      ('&', "_amp"),  ('/', "_div"),  ('=', "_eq"),
    ('?', "_qm"),   ('\\', "_back"),     ('*', "_star"), ('+', "_plus"), ('~', "_tilde"),
    ('\'', "_tick"),('#', "_num"),      ('-', "_minus"),('.', "_dot"),  (':', "_colon"),   -- '#
    (',', "c"),(';', "_semi"),     ('@', "_at"),   ('|', "_bar"),  ('<', "_lt"),
    ('>', "_gt"),   ('•', "_bullet"),   ('«', "_lang"), ('»', "_rang"), ('¦', "_bar2"),
    ('¿', "_iqm"),  ('€', "_euro"),     ('£', "_pound"),('¥', "_yen"),  ('¢', "_cent"),
    ('¬', "_not"),  ('±', "_plusminus"),('¡', "_iexcl"),('¤', "_money"),('©', "_copy"),
    ('®', "_trade"),('¹', "_one"),      ('$', "_dollar"),
    ('[', "_lbrack"), (']', "_rbrack"), ('(', "l_"), (')', "_r")]


--- look in 'graphReplacements' for character translation, if not there, use ordinal number
replaceGraphic c = case graphReplacements.lookup c of
    Just s ->  s
    Nothing -> unpacked (String.format "_%d" (ord c))


{--
    encode certain special characters so that the result is a
    valid java identifier
 -}
mangled :: String -> String
mangled s | s.startsWith "(," = "Tuple" ++ show (length s - 2 + 1)
mangled "()" = "Unit"
mangled "[]" = "List"
mangled ":"  = "Cons"
mangled "->" = "Function"
mangled s = (repljavakws . packed . loop . unpacked) s
    where
        loop (a:xs)
            | a.isLetterOrDigit
              || a == '$' || a == '_' = a : loop xs
            | (b:ys) <- xs,
              Char.isSurrogatePair a b,
              cp <- Char.toCodePoint a b,
              Char.isLetter cp || Char.isDigit cp = a:b:loop ys
            | otherwise = (replaceGraphic a) ++ loop xs
        loop [] = []

{--
    Replace lower case latin single letter type variables with 
    matheatical capitals.
    
    This will make Java type annotations look more familiar, like:
    
    > class Functor f where fmap :: (a -> b) -> f a -> f b
    
    would read in Java
    
    > interface Functor<𝓕 extends Kind.U<𝓕,?> {
    >    public<𝓐, 𝓑> Kind.U<𝓕, 𝓑> fmap(Func.U<𝓐, 𝓑> f, Kind.U<𝓕, 𝓐> v)
    > }  
-}
mangleJtv name
    | name ~ '^[a-z]$' = elemAt jtvArray (ord (name.charAt 0) - ord 'a')
    | name ~ '[a-z]'   = "𝓣" ++ name    -- prepend 𝓣 before latin name
    | otherwise        = name           -- not latin, leave as is


private !alphabet = [
    (1_000_000_000, 'T', 100_000_000, 'R'),
    (  500_000_000, 'S', 100_000_000, 'R'),
    (100_000_000, 'R', 10_000_000, 'O'),
    ( 50_000_000, 'P', 10_000_000, 'O'),
    (10_000_000, 'O', 1_000_000, 'K'),
    ( 5_000_000, 'N', 1_000_000, 'K'),
    (1000000, 'K', 100000, 'H'),
    ( 500000, 'J', 100000, 'H'),
    (100000, 'H', 10000, 'F'),
    ( 50000, 'G', 10000, 'F'),
    (10000, 'F', 1000, 'M'),
    ( 5000, 'E', 1000, 'M'), 
    (1000, 'M', 100, 'C'),
    ( 500, 'D', 100, 'C'),
    ( 100, 'C',  10, 'X'),
    (  50, 'L',  10, 'X'),
    (  10, 'X',   1, 'I'),
    (   5, 'V',   1, 'I'),
    (   1, 'I',   0, 'Z')
    ]

!romNums = arrayCache (\n arr -> packed (romanNumber n)) 100
romanUpper x
    | x >= 0, x < 100 = romNums `elemAt` x
    | otherwise       = packed (romanNumber x)

romanLower x = (romanUpper x).toLowerCase

romanNumber n 
    | n == minBound = '-' : 'T' : rom alphabet (abs (n + 1_000_000_000))
    | n < 0     = '-' : rom alphabet (abs n)
    | n == 0    = ['Z']
    | otherwise = rom alphabet n
    where
        rom :: [(Int, Char, Int, Char)] -> Int -> [Char]
        rom (alpha@(u, uc, d, dc):xs) n
            | n >= u = uc : rom alpha (n-u)
            | n >= (u-d) = dc : uc : rom xs (n-u+d)
            | otherwise  = rom xs n
        rom [] 0 = []
        rom xx y = error ("rom " ++ show xx ++ " " ++ show y) 
