--- General functions that work on types
module frege.compiler.common.Types 
        inline (isFun)
    where 

import  Data.TreeMap as Map(member, keys, TreeSet, TreeMap)

import  frege.compiler.types.Types as T
import  Compiler.types.Global as G
import  Compiler.types.QNames (QName)
import  Compiler.types.Kinds
import  Compiler.types.Positions (Position, getpos)
import  Compiler.types.Packs(pPreludeBase)
import  frege.compiler.classes.Nice(Nice)

--- tell if the 'SigmaT' represents a function type. 
isFun (ForAll _ rho) g = isRhoFun rho g

--- tell if the 'RhoT' represents a function type.
isRhoFun (RhoFun _ _ _) g = true
isRhoFun (RhoTau _ tau) g = isTauFun tau g


--- tell if the 'TauT' represents a function type.
isTauFun fun g | [TCon {name}, _, _] <- Tau.flat fun, name.nice g ~ ´->$´ = true
               | otherwise =  false


--- find all unbound 'MetaTv's in a 'Sigma'
unboundSigmaTvs g sigma = keys (unboundSigmaTvs' g sigma TreeSet.empty)

--- find all unbound 'MetaTv's in a 'Rho'
unboundRhoTvs g rho = keys (unboundRhoTvs' g rho TreeSet.empty) 

--- find all unbound 'MetaTv's in a 'Tau'
unboundTauTvs g tau = keys (unboundTauTvs' g tau TreeSet.empty) 


--- accumulate unbound 'MetaTv's of a 'Sigma'
unboundSigmaTvs' g (ForAll{rho}) acc = unboundRhoTvs' g rho acc

--- accumulate unbound 'MetaTv's from the components of a 'Rho'
unboundRhoTvs' g RhoFun{context, sigma, rho} acc = 
    unboundRhoTvs' g rho (
        unboundSigmaTvs' g sigma (
            fold (unboundCtxTvs' g) acc context))
unboundRhoTvs' g RhoTau{context, tau} acc = 
    unboundTauTvs' g tau (fold (unboundCtxTvs' g) acc context)

--- accumulate unbound 'MetaTv's of a 'Context'
unboundCtxTvs' g acc Ctx{pos, cname, tau}  = unboundTauTvs' g tau acc

--- accumulate unbound 'MetaTv's of a 'Tau'
unboundTauTvs' ∷ Global → TauT a → TreeSet Int → TreeSet Int
unboundTauTvs' g (TApp a b) acc =
    unboundTauTvs' g a (unboundTauTvs' g b acc)
unboundTauTvs' g (TSig s) acc = unboundSigmaTvs' g s acc
unboundTauTvs' g (Meta m) acc = case m  of
    -- This is what we are looking for.
    -- If the meta type variable has no entry in the type substitution map,
    -- then it is unbound.
    Flexi{uid} →  case g.tySubst.lookupI uid of
        Just t  → unboundTauTvs' g t acc    -- follow substitution
        Nothing → acc.insertI uid ()        -- would print as t<uid>
    Rigid{} →  acc

unboundTauTvs' g TVar{} acc = acc
unboundTauTvs' g TCon{} acc = acc

--- substitute 'MetaTv' unique ids in a 'Sigma'
substSigmaUID :: Global -> TreeMap Int Int → Sigma → Sigma
substSigmaUID g m sigma = sigma.{rho ← substRhoUID g m}

--- substitute 'MetaTv' unique ids in a 'Rho'
substRhoUID :: Global -> TreeMap Int Int → Rho → Rho
substRhoUID g m (r@RhoFun{})  = r.{context ← map (substCtxUID g m), 
                                 sigma   ← substSigmaUID g m, 
                                 rho     ← substRhoUID g m}
substRhoUID g m (r@RhoTau{})  = r.{context ← map (substCtxUID g m), 
                                 tau     ← substTauUID g m}

--- substitute 'MetaTv' unique ids in a 'Context'
substCtxUID :: Global -> TreeMap Int Int -> Context -> Context
substCtxUID g m ctx = ctx.{tau <- substTauUID g m}

--- substitute 'MetaTv' unique ids in a 'Tau'
substTauUID :: Global -> TreeMap Int Int -> Tau -> Tau
substTauUID g m tau = case tau  of
    TApp a b →  TApp (substTauUID g m a) (substTauUID g m b)
    TCon{} →  tau
    TVar{} →  tau
    TSig s →  TSig (substSigmaUID g m s)
    Meta v →  case v  of
        Flexi{uid}
            -- if this UID is in the substitution map, we insert the fake UID 
            | Just n <- m.lookupI uid           → Meta v.{uid=n}
            -- if the type var was actually bound, we substitute the bound type
            | Just t <- g.tySubst.lookupI uid   → substTauUID g m t
            -- this should not happen, as every unbound Meta var must be in the map
            -- anyway, we spare us detecting an impossible error, and let it fall through 
        _  →  tau

--- A list of unused MetaTv UID for substitution
--- Experience shows that real UIDs are quite big, like 17432, so it should be [1,2,3,...]
smallUIDs :: Global -> [Int]
smallUIDs g = [ n | n <- [1..], not (member n g.tySubst) ] 


class BetterReadable t where
    {-- 
        Make a type better readable (like in error messages)
        by replacing the UIDs of unbound 'MetaTv's with small numbers.
        
        This should cause types like
        > t12345 -> t54231 -> t54312
        to become
        > t1 -> t2 -> t3

        Note: The result of 'betterReadable' is a fake type
        and must not be used in actual type inference! 
    -}
    betterReadable :: Global -> t -> t

instance BetterReadable Sigma where
    betterReadable g s = substSigmaUID g (Map.fromList subst) s where
        subst = zip (unboundSigmaTvs g s) (smallUIDs g)

instance BetterReadable Rho where
    betterReadable g s = substRhoUID g (Map.fromList subst) s where
        subst = zip (unboundRhoTvs g s) (smallUIDs g)

instance BetterReadable Tau where
    betterReadable g s = substTauUID g (Map.fromList subst) s where
        subst = zip (unboundTauTvs g s) (smallUIDs g)

{--
 * make @RhoFun a b@ to @RhoTau (TFun a b)@ 
 -}
tauRho (RhoFun ctxs (ForAll [] (RhoTau [] a)) rho2)
    | RhoTau _ b <- tauRho rho2 = RhoTau ctxs (Tau.tfun a b)
tauRho r = r


{--
    Takes a class name @C@ and a 'Rho' type
    >  (A a, B b) ⇒ F a b
    and construct a fake type that will be printed like an 
    ordinary instance head, e.g.
    >  (A a, B b) ⇒ C (F a b)
-}
instanceHead :: QName -> Rho -> Rho
instanceHead clas rho = RhoTau{context=rho.context, tau=TApp tcon tau}
    where
        tau = (tauRho rho).tau
        tcon = TCon{pos=getpos tau, name=clas}
        

--- note: type must not contain bound Metas
substSigma :: TreeMap String (TauT t) ->  SigmaT t  -> SigmaT t
substSigma t (ForAll bndrs rho) = ForAll bndrs (substRho t' rho)
    where t' = fold TreeMap.delete t (map fst bndrs)


substRho t (RhoFun ctx sig rho) = let
            ctx' = map (substCtx t) ctx
            sig' = substSigma t sig 
            rho' = substRho t rho 
        in (RhoFun ctx' sig' rho')
substRho t (RhoTau ctx tau)  = RhoTau (map (substCtx t) ctx) (substTau t tau)



substTau t (tau@TCon{})      = tau
substTau t (TApp a b)        = TApp (substTau t a) (substTau t b)
substTau t (typ@Meta _)      = typ     -- Meta must be unbound
substTau t (typ@TVar {var})  = case TreeMap.lookupS t var of
        Just tau -> tau
        Nothing  -> typ
substTau t (typ@TSig s) = TSig (substSigma t s)



substCtx :: TreeMap String (TauT a) -> ContextT a -> ContextT a        
substCtx t x  = x.{tau <- substTau t}


--- The identity type constructor from the Prelude
identityTyCon ∷ Position → Tau
identityTyCon pos = TCon{pos, name = TName pPreludeBase "𝑰"}

--- check if this is the identity type constructor @𝑰@
isIdentityTyCon ∷ Tau → Bool
isIdentityTyCon TCon{name = TName prel "𝑰"}  =  prel == pPreludeBase
isIdentityTyCon other                        =  false

--- check if the type is of the form @𝑰 a@
isIdentityType (TApp a b) = isIdentityTyCon a
isIdentityType other      = false

--- Make @(𝑰 a)@ from @a@, but avoid @𝑰 (𝑰 a)@
typeIdentity ∷ Tau → Tau
typeIdentity t
    | isIdentityType t = t
    | otherwise        = TApp (identityTyCon (getpos t)) t

-- substitution functions with 𝑰 type
--- note: type must not contain bound Metas
--- Whenever a type variable is substituted with a type, 'typeIdentity' is applied 
substIdSigma :: TreeMap String Tau ->  Sigma  -> Sigma
substIdSigma t (ForAll bndrs rho) = ForAll bndrs (substIdRho t' rho)
    where t' = fold TreeMap.delete t (map fst bndrs)


substIdRho t (RhoFun ctx sig rho) = let
            ctx' = map (substCtx t) ctx
            sig' = substIdSigma t sig 
            rho' = substIdRho t rho 
        in (RhoFun ctx' sig' rho')
substIdRho t (RhoTau ctx tau)  = RhoTau (map (substCtx t) ctx) (substIdTau t tau)



substIdTau t (tau@TCon{})      = tau
substIdTau t (TApp a b)        = TApp (substIdTau t a) (substIdTau t b)
substIdTau t (typ@Meta _)      = typ     -- Meta must be unbound
substIdTau t (typ@TVar {var})  = case TreeMap.lookupS t var of
        Just tau
            | Just _ ← tau.getFun = typeIdentity tau
            | otherwise           = tau
        Nothing  -> typ
substIdTau t (typ@TSig s) = TSig (substIdSigma t s)

--- tell the kind of the result
resultKind (ForAll _ rho) = resultRhoKind rho
--- tell the kind of the result
resultRhoKind RhoFun{context, sigma, rho} = resultRhoKind rho
resultRhoKind RhoTau{tau} = resultTauKind tau

--- tell the kind of this 'Tau'
resultTauKind :: Tau -> Kind
resultTauKind app = case app.flat of
    TVar{pos, kind, var}:_          →  kind
    Meta Flexi{uid, hint, kind}:_   →  kind
    other                           →  KType