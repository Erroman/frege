--- The non-recursive form of several types,as used in @GenMeta@
--- This corresponds closely to the interfaces in @frege.runtime.Meta@
module frege.compiler.types.External where 

import  frege.compiler.types.QNames
import  frege.data.JSON (ToJSON, maybeToJSON, toJSON)

{-- 
    Encode 'Tau' types and 'Kind's.

    The @kind@ field encodes what it is:
    0) 'TApp', uses fields @suba@ and @subb@ to point to affected 'Tau's
    1) unused
    2) 'TCon', uses field @tcon@
    3) 'TVar', uses field @tvar@ for the name and @suba@ for an index that encode a 'Kind'
    8) 'KApp', uses fields @suba@ and @subb@ to point to affected 'Kind's
    9) 'KType'
    10) 'KVar' (should not happen)
    11) 'KGen' uses field @suba@ to point to a 'Tau'
--}
data TauA = TauA {!kind::Int, !tcon::Maybe QName, !suba::Int, !subb::Int, !tvar::String}
derive ArrayElement TauA
derive Eq  TauA
derive Ord TauA

instance ToJSON TauA where
  toJSON x = JSON.Struct
    [ JSON.assoc "kind" x.kind
    , JSON.assoc "tcon" $ maybeToJSON x.tcon
    , JSON.assoc "suba" x.suba
    , JSON.assoc "subb" x.subb
    , JSON.assoc "tvar" x.tvar
    ]


data RhoA = RhoA {!rhofun::Bool, !cont::[ContextA], !sigma::Int, !rhotau::Int}
derive ArrayElement RhoA
derive Eq  RhoA
derive Ord RhoA

instance ToJSON RhoA where
  toJSON x = JSON.Struct
    [ JSON.assoc "rhofun" x.rhofun
    , JSON.assoc "cont" x.cont
    , JSON.assoc "sigma" x.sigma
    , JSON.assoc "rhotau" x.rhotau
    ]


data ContextA = CtxA {!clas::QName, !tau::Int}
derive Eq  ContextA
derive Ord ContextA

instance ToJSON ContextA where
  toJSON x = JSON.Struct
    [ JSON.assoc "clas" x.clas
    , JSON.assoc "tau" x.tau
    ]


data SigmaA = SigmaA {!bound::[String], !kinds::[Int], !rho::Int}
derive ArrayElement SigmaA
derive Eq  SigmaA
derive Ord SigmaA

instance ToJSON SigmaA where
  toJSON x = JSON.Struct
    [ JSON.assoc "bound" x.bound
    , JSON.assoc "kinds" x.kinds
    , JSON.assoc "rho" x.rho
    ]


data ExprA = !ExprA {xkind::Int, name::Maybe QName, lkind::Int, varval::Maybe String,
                    alts :: [Int], subx1 :: Int, subx2 :: Int, subx3 :: Int}
derive ArrayElement ExprA
derive Eq  ExprA
derive Ord ExprA

instance ToJSON ExprA where
  toJSON x = JSON.Struct
    [ JSON.assoc "xkind" x.xkind
    , JSON.assoc "name" x.name
    , JSON.assoc "lkind" x.lkind
    , JSON.assoc "varval" $ maybeToJSON x.varval
    , JSON.assoc "alts" x.alts
    , JSON.assoc "subx1" x.subx1
    , JSON.assoc "subx2" x.subx2
    , JSON.assoc "subx3" x.subx3
    ]


--- default "serialized" expression
defEA = ExprA {xkind = 7, name = Nothing, lkind = 0, varval = Nothing, alts = [],
                subx1 = 0, subx2 = 0, subx3 = 0}


