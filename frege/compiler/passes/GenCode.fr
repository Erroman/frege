--- Code generation compatible with Java7 *or* Java8 syntax

{--
    ## Concepts

    ### Data types

    Representation of data types doesn't change.


    ### Instances

    Instance functions can now be called directly via the instance
    object, instead of first getting a function pointer.


    ### Higher order functions

    Arguments that have a function type are always strict.


    ### Function arity
    
    The code generator keeps track of the arity of functions.
    For example, in @flip :: (a -> b -> c) -> b -> a -> c@
    it will pass and expect a @Func2@. If you pass a function @f@ with
    arity 1 to @flip@, it will be wrapped in an extra lambda
    @\a\b -> (f a) $ b@.

    When you pass a function @g@ with a higher arity, say 4,
    it will be wrapped in a lambda @(\a\b -> (\x3\x4 -> g a b x3 x4))@.
    
    Fortunately, the compiler will have established type soundness
    during type checking, so that in the first case we know that
    the unary function actually returns another unary function and the
    application @flip g a b@ yields a binary function.


    ### Partial applications
    
    Partial applications like  @flip (-)@ are eta-expanded to  
    @\a\b -> flip (-) a b@. 
    
    A special case of partial application is when a function is not 
    applied at all - like in @fold (+) 0 xs@.


    ### Lazy values
    
    Lazy values will be instances of @java.run.Lazy@, that is in 
    Java8 notation @() -> some code@. Those are not shared.
    
    Shared lazy values (i.e. in @let@ or arguments for constructors) are 
    @new Thunk(() -> value)@.

    Thunk and Lazy know their return type, i.e. they are generic types.


    ## The Four Reasons for Stack Overflow

    ### Tail Calls

    Tail calls are dangerous, unless the tail called function is _tail call safe_.
    A function is _tail call safe_ if one of the following applies:

    - it is a constructor
    - it is a native function
    - it is not recursive and calls only tail call safe functions
    
    In particular, a function passed as argument is not tail call safe.
    
    If the result of a function that is not tail call safe is a (full)
    application of another function, and this function is itself not 
    tail call safe, or a full application of a non tail call safe function
    appears in a strict position, then a Lazy closure must be returned 
    instead of doing the call directly.
    
    Examples:
    
    > even 0 = true
    > even n = odd (n-a)
    > odd  0 = false
    > odd  n = even (n-1)
    
    Both @even@ and @odd@ are clearly unsafe, hence the code for @even@ 
    should be:
    
    > Lazy<java.lang.Boolean> even(int n) {
    >    if (n==0) then return new Thunk(true);
    >    return new Thunk(() -> even(n-1));
    > }
    
    ### @foldr@ Recursion
    
    > foldr f d [] = d
    > foldr f d (x:xs) = x `f` foldr f d xs
    
    If `f` is strict in its right argument, this leads to recursion as deep
    as the length of the list.
    This could be solved when the currently evaluating thread 
-}

module frege.compiler.passes.GenCode where

import Lib.PP(pretty)
import Data.TreeMap(TreeMap, values)
import Data.Graph (stronglyConnectedComponents tsort)

import Compiler.Utilities as U()

import Compiler.types.Global
import Compiler.types.JNames
import Compiler.types.Symbols

import Compiler.common.Annotate (anno)

import Compiler.gen.java.Common
import Compiler.gen.java.Abstract
import Compiler.gen.java.VarCode(varCode)


pass :: StIO (String, Int)
pass = do
    g   ← getSTT
        
    let modul = JClass{attr=attrs [JFinal, JPublic], 
                    name = (mainClass g).base, gvars=[], 
                    extend = fmap (sigmaJT g) g.options.extends, 
                    implement = map (sigmaJT g) g.options.implements, 
                    defs=[]}
        headline = (pretty 2000 (anno modul)).replaceAll ´}´ ""

    --  class my.modul.Name extends ... implements ... {
    
    -- Note that we don't make a JClass that contains all compiled definitions,
    -- although this would be the natural approach. Instead we compile and
    -- pretty print the definitions individually. This allows us to 
    -- do the pretty printing concurrently.
    U.println headline
    
    -- print the embedded Java code 
    reconstruct (g.options.code)
    
    -- do variables in dependency order, this is so that CAFs refer only to CAFs
    -- whose java initialization occurs earlier
    let vars = [ s | s@SymV {} <- values g.thisTab ]
        -- varCode _  = pure . (:[]) . JComment . _.base . Symbol.name 
    -- names   <- mapSt U.fundep vars
    -- varsyms <- mapSt U.findV (concat (U.tsort names))
    vdecls ← liftStG (
            mapSt U.fundep vars 
            >>= mapSt U.findV . concat . tsort 
            >>= mapSt (varCode TreeMap.empty))

    liftIO $ (ppDecls g . concat) vdecls 

    U.println "}"       -- supply the } that was removed from the headline
    return ("Gen78", 1)


--- Print some declarations stacked
ppDecls :: Global -> [JDecl] → IO ()
ppDecls g decls = do
    PP.prettyIO g.printer 96 . PP.stack . map anno $ decls
    g.printer.println